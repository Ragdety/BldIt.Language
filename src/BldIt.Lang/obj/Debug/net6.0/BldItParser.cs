//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\ragde\OneDrive\Desktop\Programming\BldIt\BldIt.Language\src\BldIt.Lang\Grammar\BldItParser.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace BldIt.Lang.Grammar {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class BldItParser : Parser {
	public const int
		INDENT=1, DEDENT=2, PIPELINE=3, GLOBALENV=4, PARAMETERS=5, STAGES=6, STAGE=7, 
		HANDLE_ERROR=8, WHILE=9, FUNCTION=10, RETURN=11, ADD_OP=12, SUB_OP=13, 
		MULT_OP=14, DIV_OP=15, MOD_OP=16, BOOL_OP=17, GREATER_THAN_OP=18, LESS_THAN_OP=19, 
		GREATER_THAN_EQUAL_OP=20, LESS_THAN_EQUAL_OP=21, OPEN_PAREN=22, CLOSE_PAREN=23, 
		COMMA=24, SEMICOLON=25, COLON=26, DOT=27, ASSIGN_OP=28, IF=29, ELSE=30, 
		EQUALITY=31, NOT=32, PARAM_TYPE=33, SCRIPT=34, NEWLINE=35, SKIP_=36, INTEGER=37, 
		FLOAT=38, STRING=39, BOOL=40, NULL=41, ENDLINE=42, IDENTIFIER=43;
	public const int
		RULE_bldItFile = 0, RULE_statements = 1, RULE_statement = 2, RULE_simpleStatement = 3, 
		RULE_compoundStatement = 4, RULE_ifStatement = 5, RULE_singleIfBlock = 6, 
		RULE_elseIfBlock = 7, RULE_elseBlock = 8, RULE_whileStatement = 9, RULE_functionDefinition = 10, 
		RULE_parameters = 11, RULE_block = 12, RULE_functionBlock = 13, RULE_returnStatement = 14, 
		RULE_assignment = 15, RULE_functionCall = 16, RULE_expression = 17, RULE_parenthExpression = 18, 
		RULE_notExpression = 19, RULE_multOp = 20, RULE_addOp = 21, RULE_compareOp = 22, 
		RULE_boolOp = 23, RULE_constant = 24, RULE_pipeline = 25, RULE_globalEnvStatement = 26, 
		RULE_parameterStatement = 27, RULE_stagesStatement = 28, RULE_globalEnvBlock = 29, 
		RULE_parameterBlock = 30, RULE_stagesBlock = 31, RULE_stageStatement = 32, 
		RULE_stageBlock = 33, RULE_stepStatement = 34, RULE_simpleStepStatement = 35, 
		RULE_pipelineSimpleStepCall = 36, RULE_compoundStepStatement = 37, RULE_handleErrorStep = 38, 
		RULE_handleErrorBlock = 39, RULE_scriptStep = 40, RULE_scriptBlock = 41, 
		RULE_scriptStatements = 42, RULE_scriptStatament = 43, RULE_envAssignments = 44, 
		RULE_envAssignment = 45, RULE_paramAssignments = 46, RULE_paramAssignment = 47, 
		RULE_paramValue = 48, RULE_pipelineExpression = 49;
	public static readonly string[] ruleNames = {
		"bldItFile", "statements", "statement", "simpleStatement", "compoundStatement", 
		"ifStatement", "singleIfBlock", "elseIfBlock", "elseBlock", "whileStatement", 
		"functionDefinition", "parameters", "block", "functionBlock", "returnStatement", 
		"assignment", "functionCall", "expression", "parenthExpression", "notExpression", 
		"multOp", "addOp", "compareOp", "boolOp", "constant", "pipeline", "globalEnvStatement", 
		"parameterStatement", "stagesStatement", "globalEnvBlock", "parameterBlock", 
		"stagesBlock", "stageStatement", "stageBlock", "stepStatement", "simpleStepStatement", 
		"pipelineSimpleStepCall", "compoundStepStatement", "handleErrorStep", 
		"handleErrorBlock", "scriptStep", "scriptBlock", "scriptStatements", "scriptStatament", 
		"envAssignments", "envAssignment", "paramAssignments", "paramAssignment", 
		"paramValue", "pipelineExpression"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, "'globalEnv'", "'parameters'", "'stages'", "'stage'", 
		"'handleError'", "'while'", null, null, "'+'", "'-'", "'*'", "'/'", "'%'", 
		null, "'>'", "'<'", "'>='", "'<='", "'('", "')'", "','", "';'", "':'", 
		"'.'", "'='", "'if'", "'else'", null, null, null, "'script'", null, null, 
		null, null, null, null, "'null'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "INDENT", "DEDENT", "PIPELINE", "GLOBALENV", "PARAMETERS", "STAGES", 
		"STAGE", "HANDLE_ERROR", "WHILE", "FUNCTION", "RETURN", "ADD_OP", "SUB_OP", 
		"MULT_OP", "DIV_OP", "MOD_OP", "BOOL_OP", "GREATER_THAN_OP", "LESS_THAN_OP", 
		"GREATER_THAN_EQUAL_OP", "LESS_THAN_EQUAL_OP", "OPEN_PAREN", "CLOSE_PAREN", 
		"COMMA", "SEMICOLON", "COLON", "DOT", "ASSIGN_OP", "IF", "ELSE", "EQUALITY", 
		"NOT", "PARAM_TYPE", "SCRIPT", "NEWLINE", "SKIP_", "INTEGER", "FLOAT", 
		"STRING", "BOOL", "NULL", "ENDLINE", "IDENTIFIER"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "BldItParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public BldItParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class BldItFileContext : ParserRuleContext {
		public PipelineContext pipeline() {
			return GetRuleContext<PipelineContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(BldItParser.Eof, 0); }
		public ITerminalNode[] NEWLINE() { return GetTokens(BldItParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(BldItParser.NEWLINE, i);
		}
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public BldItFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bldItFile; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterBldItFile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitBldItFile(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBldItFile(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BldItFileContext bldItFile() {
		BldItFileContext _localctx = new BldItFileContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_bldItFile);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 104;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WHILE) | (1L << FUNCTION) | (1L << RETURN) | (1L << IF) | (1L << NEWLINE) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 102;
				_errHandler.Sync(this);
				switch (_input.La(1)) {
				case NEWLINE:
					{
					State = 100; Match(NEWLINE);
					}
					break;
				case WHILE:
				case FUNCTION:
				case RETURN:
				case IF:
				case IDENTIFIER:
					{
					State = 101; statement();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 106;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 107; pipeline();
			State = 108; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitStatements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		StatementsContext _localctx = new StatementsContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_statements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 111;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 110; statement();
				}
				}
				State = 113;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WHILE) | (1L << FUNCTION) | (1L << RETURN) | (1L << IF) | (1L << IDENTIFIER))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_statement);
		try {
			State = 117;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case RETURN:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 115; simpleStatement();
				}
				break;
			case WHILE:
			case FUNCTION:
			case IF:
				EnterOuterAlt(_localctx, 2);
				{
				State = 116; compoundStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleStatementContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		public ITerminalNode SEMICOLON() { return GetToken(BldItParser.SEMICOLON, 0); }
		public SimpleStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterSimpleStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitSimpleStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleStatementContext simpleStatement() {
		SimpleStatementContext _localctx = new SimpleStatementContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_simpleStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				{
				State = 119; assignment();
				}
				break;

			case 2:
				{
				State = 120; functionCall();
				}
				break;

			case 3:
				{
				State = 121; returnStatement();
				}
				break;
			}
			State = 125;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==SEMICOLON) {
				{
				State = 124; Match(SEMICOLON);
				}
			}

			State = 127; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundStatementContext : ParserRuleContext {
		public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		public FunctionDefinitionContext functionDefinition() {
			return GetRuleContext<FunctionDefinitionContext>(0);
		}
		public CompoundStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterCompoundStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitCompoundStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompoundStatementContext compoundStatement() {
		CompoundStatementContext _localctx = new CompoundStatementContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_compoundStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case IF:
				{
				State = 129; ifStatement();
				}
				break;
			case WHILE:
				{
				State = 130; whileStatement();
				}
				break;
			case FUNCTION:
				{
				State = 131; functionDefinition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		public SingleIfBlockContext singleIfBlock() {
			return GetRuleContext<SingleIfBlockContext>(0);
		}
		public ElseIfBlockContext[] elseIfBlock() {
			return GetRuleContexts<ElseIfBlockContext>();
		}
		public ElseIfBlockContext elseIfBlock(int i) {
			return GetRuleContext<ElseIfBlockContext>(i);
		}
		public ElseBlockContext elseBlock() {
			return GetRuleContext<ElseBlockContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_ifStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 134; singleIfBlock();
			State = 138;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 135; elseIfBlock();
					}
					} 
				}
				State = 140;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			}
			State = 142;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 141; elseBlock();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleIfBlockContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(BldItParser.IF, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public SingleIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleIfBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterSingleIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitSingleIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleIfBlockContext singleIfBlock() {
		SingleIfBlockContext _localctx = new SingleIfBlockContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_singleIfBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144; Match(IF);
			State = 145; expression(0);
			State = 146; Match(COLON);
			State = 147; block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseIfBlockContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(BldItParser.ELSE, 0); }
		public ITerminalNode IF() { return GetToken(BldItParser.IF, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ElseIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseIfBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterElseIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitElseIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseIfBlockContext elseIfBlock() {
		ElseIfBlockContext _localctx = new ElseIfBlockContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_elseIfBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 149; Match(ELSE);
			State = 150; Match(IF);
			State = 151; expression(0);
			State = 152; Match(COLON);
			State = 153; block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseBlockContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(BldItParser.ELSE, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ElseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterElseBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitElseBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseBlockContext elseBlock() {
		ElseBlockContext _localctx = new ElseBlockContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_elseBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 155; Match(ELSE);
			State = 156; Match(COLON);
			State = 157; block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		public ITerminalNode WHILE() { return GetToken(BldItParser.WHILE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterWhileStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitWhileStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_whileStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 159; Match(WHILE);
			State = 160; expression(0);
			State = 161; Match(COLON);
			State = 162; block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDefinitionContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(BldItParser.FUNCTION, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(BldItParser.IDENTIFIER, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(BldItParser.OPEN_PAREN, 0); }
		public ITerminalNode CLOSE_PAREN() { return GetToken(BldItParser.CLOSE_PAREN, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public FunctionBlockContext functionBlock() {
			return GetRuleContext<FunctionBlockContext>(0);
		}
		public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		public FunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterFunctionDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitFunctionDefinition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDefinitionContext functionDefinition() {
		FunctionDefinitionContext _localctx = new FunctionDefinitionContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_functionDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 164; Match(FUNCTION);
			State = 165; Match(IDENTIFIER);
			State = 166; Match(OPEN_PAREN);
			State = 168;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==IDENTIFIER) {
				{
				State = 167; parameters();
				}
			}

			State = 170; Match(CLOSE_PAREN);
			State = 171; Match(COLON);
			State = 172; functionBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParametersContext : ParserRuleContext {
		public ITerminalNode[] IDENTIFIER() { return GetTokens(BldItParser.IDENTIFIER); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(BldItParser.IDENTIFIER, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(BldItParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(BldItParser.COMMA, i);
		}
		public ParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParameters(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParametersContext parameters() {
		ParametersContext _localctx = new ParametersContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_parameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 174; Match(IDENTIFIER);
			State = 179;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 175; Match(COMMA);
				State = 176; Match(IDENTIFIER);
				}
				}
				State = 181;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_block);
		try {
			State = 188;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case RETURN:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 182; simpleStatement();
				}
				break;
			case NEWLINE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 183; Match(NEWLINE);
				State = 184; Match(INDENT);
				State = 185; statements();
				State = 186; Match(DEDENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionBlockContext : ParserRuleContext {
		public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public FunctionBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterFunctionBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitFunctionBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionBlockContext functionBlock() {
		FunctionBlockContext _localctx = new FunctionBlockContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_functionBlock);
		int _la;
		try {
			State = 197;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case RETURN:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 190; simpleStatement();
				}
				break;
			case NEWLINE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 191; Match(NEWLINE);
				State = 192; Match(INDENT);
				State = 194;
				_errHandler.Sync(this);
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WHILE) | (1L << FUNCTION) | (1L << RETURN) | (1L << IF) | (1L << IDENTIFIER))) != 0)) {
					{
					State = 193; statements();
					}
				}

				State = 196; Match(DEDENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(BldItParser.RETURN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterReturnStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitReturnStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_returnStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 199; Match(RETURN);
			State = 201;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OPEN_PAREN) | (1L << NOT) | (1L << INTEGER) | (1L << FLOAT) | (1L << STRING) | (1L << BOOL) | (1L << NULL) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 200; expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(BldItParser.IDENTIFIER, 0); }
		public ITerminalNode ASSIGN_OP() { return GetToken(BldItParser.ASSIGN_OP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterAssignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitAssignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_assignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 203; Match(IDENTIFIER);
			State = 204; Match(ASSIGN_OP);
			State = 205; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(BldItParser.IDENTIFIER, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(BldItParser.OPEN_PAREN, 0); }
		public ITerminalNode CLOSE_PAREN() { return GetToken(BldItParser.CLOSE_PAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(BldItParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(BldItParser.COMMA, i);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_functionCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207; Match(IDENTIFIER);
			State = 208; Match(OPEN_PAREN);
			State = 217;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OPEN_PAREN) | (1L << NOT) | (1L << INTEGER) | (1L << FLOAT) | (1L << STRING) | (1L << BOOL) | (1L << NULL) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 209; expression(0);
				State = 214;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 210; Match(COMMA);
					State = 211; expression(0);
					}
					}
					State = 216;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 219; Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConstantExprContext : ExpressionContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ConstantExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterConstantExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitConstantExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IdentifierExprContext : ExpressionContext {
		public ITerminalNode IDENTIFIER() { return GetToken(BldItParser.IDENTIFIER, 0); }
		public IdentifierExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterIdentifierExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitIdentifierExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionCallExprContext : ExpressionContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public FunctionCallExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterFunctionCallExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitFunctionCallExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCallExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedExprContext : ExpressionContext {
		public ParenthExpressionContext parenthExpression() {
			return GetRuleContext<ParenthExpressionContext>(0);
		}
		public ParenthesizedExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotExprContext : ExpressionContext {
		public NotExpressionContext notExpression() {
			return GetRuleContext<NotExpressionContext>(0);
		}
		public NotExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterNotExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitNotExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiplicativeExprContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public MultOpContext multOp() {
			return GetRuleContext<MultOpContext>(0);
		}
		public MultiplicativeExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterMultiplicativeExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitMultiplicativeExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicativeExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AdditiveExprContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public AddOpContext addOp() {
			return GetRuleContext<AddOpContext>(0);
		}
		public AdditiveExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterAdditiveExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitAdditiveExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ComparisonExprContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public CompareOpContext compareOp() {
			return GetRuleContext<CompareOpContext>(0);
		}
		public ComparisonExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterComparisonExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitComparisonExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparisonExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BooleanExprContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public BoolOpContext boolOp() {
			return GetRuleContext<BoolOpContext>(0);
		}
		public BooleanExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterBooleanExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitBooleanExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 34;
		EnterRecursionRule(_localctx, 34, RULE_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 227;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,17,_ctx) ) {
			case 1:
				{
				_localctx = new ConstantExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 222; constant();
				}
				break;

			case 2:
				{
				_localctx = new IdentifierExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 223; Match(IDENTIFIER);
				}
				break;

			case 3:
				{
				_localctx = new FunctionCallExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 224; functionCall();
				}
				break;

			case 4:
				{
				_localctx = new ParenthesizedExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 225; parenthExpression();
				}
				break;

			case 5:
				{
				_localctx = new NotExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 226; notExpression();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 247;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,19,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 245;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,18,_ctx) ) {
					case 1:
						{
						_localctx = new MultiplicativeExprContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 229;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 230; multOp();
						State = 231; expression(5);
						}
						break;

					case 2:
						{
						_localctx = new AdditiveExprContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 233;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 234; addOp();
						State = 235; expression(4);
						}
						break;

					case 3:
						{
						_localctx = new ComparisonExprContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 237;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 238; compareOp();
						State = 239; expression(3);
						}
						break;

					case 4:
						{
						_localctx = new BooleanExprContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 241;
						if (!(Precpred(_ctx, 1))) throw new FailedPredicateException(this, "Precpred(_ctx, 1)");
						State = 242; boolOp();
						State = 243; expression(2);
						}
						break;
					}
					} 
				}
				State = 249;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,19,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ParenthExpressionContext : ParserRuleContext {
		public ITerminalNode OPEN_PAREN() { return GetToken(BldItParser.OPEN_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CLOSE_PAREN() { return GetToken(BldItParser.CLOSE_PAREN, 0); }
		public ParenthExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParenthExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParenthExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthExpressionContext parenthExpression() {
		ParenthExpressionContext _localctx = new ParenthExpressionContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_parenthExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250; Match(OPEN_PAREN);
			State = 251; expression(0);
			State = 252; Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NotExpressionContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(BldItParser.NOT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public NotExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_notExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterNotExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitNotExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NotExpressionContext notExpression() {
		NotExpressionContext _localctx = new NotExpressionContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_notExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 254; Match(NOT);
			State = 255; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultOpContext : ParserRuleContext {
		public ITerminalNode MULT_OP() { return GetToken(BldItParser.MULT_OP, 0); }
		public ITerminalNode DIV_OP() { return GetToken(BldItParser.DIV_OP, 0); }
		public ITerminalNode MOD_OP() { return GetToken(BldItParser.MOD_OP, 0); }
		public MultOpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multOp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterMultOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitMultOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultOpContext multOp() {
		MultOpContext _localctx = new MultOpContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_multOp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 257;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << MULT_OP) | (1L << DIV_OP) | (1L << MOD_OP))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddOpContext : ParserRuleContext {
		public ITerminalNode ADD_OP() { return GetToken(BldItParser.ADD_OP, 0); }
		public ITerminalNode SUB_OP() { return GetToken(BldItParser.SUB_OP, 0); }
		public AddOpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addOp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterAddOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitAddOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AddOpContext addOp() {
		AddOpContext _localctx = new AddOpContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_addOp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 259;
			_la = _input.La(1);
			if ( !(_la==ADD_OP || _la==SUB_OP) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompareOpContext : ParserRuleContext {
		public ITerminalNode EQUALITY() { return GetToken(BldItParser.EQUALITY, 0); }
		public ITerminalNode LESS_THAN_OP() { return GetToken(BldItParser.LESS_THAN_OP, 0); }
		public ITerminalNode GREATER_THAN_OP() { return GetToken(BldItParser.GREATER_THAN_OP, 0); }
		public ITerminalNode LESS_THAN_EQUAL_OP() { return GetToken(BldItParser.LESS_THAN_EQUAL_OP, 0); }
		public ITerminalNode GREATER_THAN_EQUAL_OP() { return GetToken(BldItParser.GREATER_THAN_EQUAL_OP, 0); }
		public CompareOpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compareOp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterCompareOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitCompareOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompareOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompareOpContext compareOp() {
		CompareOpContext _localctx = new CompareOpContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_compareOp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GREATER_THAN_OP) | (1L << LESS_THAN_OP) | (1L << GREATER_THAN_EQUAL_OP) | (1L << LESS_THAN_EQUAL_OP) | (1L << EQUALITY))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolOpContext : ParserRuleContext {
		public ITerminalNode BOOL_OP() { return GetToken(BldItParser.BOOL_OP, 0); }
		public BoolOpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolOp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterBoolOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitBoolOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolOpContext boolOp() {
		BoolOpContext _localctx = new BoolOpContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_boolOp);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 263; Match(BOOL_OP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(BldItParser.INTEGER, 0); }
		public ITerminalNode FLOAT() { return GetToken(BldItParser.FLOAT, 0); }
		public ITerminalNode STRING() { return GetToken(BldItParser.STRING, 0); }
		public ITerminalNode BOOL() { return GetToken(BldItParser.BOOL, 0); }
		public ITerminalNode NULL() { return GetToken(BldItParser.NULL, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_constant);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 265;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << FLOAT) | (1L << STRING) | (1L << BOOL) | (1L << NULL))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PipelineContext : ParserRuleContext {
		public ITerminalNode PIPELINE() { return GetToken(BldItParser.PIPELINE, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public StagesStatementContext stagesStatement() {
			return GetRuleContext<StagesStatementContext>(0);
		}
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public GlobalEnvStatementContext globalEnvStatement() {
			return GetRuleContext<GlobalEnvStatementContext>(0);
		}
		public ParameterStatementContext parameterStatement() {
			return GetRuleContext<ParameterStatementContext>(0);
		}
		public PipelineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pipeline; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterPipeline(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitPipeline(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPipeline(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PipelineContext pipeline() {
		PipelineContext _localctx = new PipelineContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_pipeline);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 267; Match(PIPELINE);
			State = 268; Match(COLON);
			State = 269; Match(NEWLINE);
			State = 270; Match(INDENT);
			State = 272;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==GLOBALENV) {
				{
				State = 271; globalEnvStatement();
				}
			}

			State = 275;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==PARAMETERS) {
				{
				State = 274; parameterStatement();
				}
			}

			State = 277; stagesStatement();
			State = 278; Match(DEDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobalEnvStatementContext : ParserRuleContext {
		public ITerminalNode GLOBALENV() { return GetToken(BldItParser.GLOBALENV, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public GlobalEnvBlockContext globalEnvBlock() {
			return GetRuleContext<GlobalEnvBlockContext>(0);
		}
		public GlobalEnvStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_globalEnvStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterGlobalEnvStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitGlobalEnvStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlobalEnvStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GlobalEnvStatementContext globalEnvStatement() {
		GlobalEnvStatementContext _localctx = new GlobalEnvStatementContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_globalEnvStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 280; Match(GLOBALENV);
			State = 281; Match(COLON);
			State = 282; globalEnvBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterStatementContext : ParserRuleContext {
		public ITerminalNode PARAMETERS() { return GetToken(BldItParser.PARAMETERS, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public ParameterBlockContext parameterBlock() {
			return GetRuleContext<ParameterBlockContext>(0);
		}
		public ParameterStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParameterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParameterStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterStatementContext parameterStatement() {
		ParameterStatementContext _localctx = new ParameterStatementContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_parameterStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 284; Match(PARAMETERS);
			State = 285; Match(COLON);
			State = 286; parameterBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StagesStatementContext : ParserRuleContext {
		public ITerminalNode STAGES() { return GetToken(BldItParser.STAGES, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public StagesBlockContext stagesBlock() {
			return GetRuleContext<StagesBlockContext>(0);
		}
		public StagesStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stagesStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterStagesStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitStagesStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStagesStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StagesStatementContext stagesStatement() {
		StagesStatementContext _localctx = new StagesStatementContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_stagesStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 288; Match(STAGES);
			State = 289; Match(COLON);
			State = 290; stagesBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobalEnvBlockContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public EnvAssignmentsContext envAssignments() {
			return GetRuleContext<EnvAssignmentsContext>(0);
		}
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public GlobalEnvBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_globalEnvBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterGlobalEnvBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitGlobalEnvBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlobalEnvBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GlobalEnvBlockContext globalEnvBlock() {
		GlobalEnvBlockContext _localctx = new GlobalEnvBlockContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_globalEnvBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 292; Match(NEWLINE);
			State = 293; Match(INDENT);
			State = 294; envAssignments();
			State = 295; Match(DEDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterBlockContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public ParamAssignmentsContext paramAssignments() {
			return GetRuleContext<ParamAssignmentsContext>(0);
		}
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public ParameterBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParameterBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParameterBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterBlockContext parameterBlock() {
		ParameterBlockContext _localctx = new ParameterBlockContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_parameterBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 297; Match(NEWLINE);
			State = 298; Match(INDENT);
			State = 299; paramAssignments();
			State = 300; Match(DEDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StagesBlockContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public StageStatementContext[] stageStatement() {
			return GetRuleContexts<StageStatementContext>();
		}
		public StageStatementContext stageStatement(int i) {
			return GetRuleContext<StageStatementContext>(i);
		}
		public StagesBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stagesBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterStagesBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitStagesBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStagesBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StagesBlockContext stagesBlock() {
		StagesBlockContext _localctx = new StagesBlockContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_stagesBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 302; Match(NEWLINE);
			State = 303; Match(INDENT);
			State = 305;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 304; stageStatement();
				}
				}
				State = 307;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==STAGE );
			State = 309; Match(DEDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StageStatementContext : ParserRuleContext {
		public ITerminalNode STAGE() { return GetToken(BldItParser.STAGE, 0); }
		public ITerminalNode STRING() { return GetToken(BldItParser.STRING, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public StageBlockContext stageBlock() {
			return GetRuleContext<StageBlockContext>(0);
		}
		public StageStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stageStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterStageStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitStageStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStageStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StageStatementContext stageStatement() {
		StageStatementContext _localctx = new StageStatementContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_stageStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 311; Match(STAGE);
			State = 312; Match(STRING);
			State = 313; Match(COLON);
			State = 314; stageBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StageBlockContext : ParserRuleContext {
		public SimpleStepStatementContext simpleStepStatement() {
			return GetRuleContext<SimpleStepStatementContext>(0);
		}
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public StepStatementContext[] stepStatement() {
			return GetRuleContexts<StepStatementContext>();
		}
		public StepStatementContext stepStatement(int i) {
			return GetRuleContext<StepStatementContext>(i);
		}
		public StageBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stageBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterStageBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitStageBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStageBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StageBlockContext stageBlock() {
		StageBlockContext _localctx = new StageBlockContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_stageBlock);
		int _la;
		try {
			State = 326;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 316; simpleStepStatement();
				}
				break;
			case NEWLINE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 317; Match(NEWLINE);
				State = 318; Match(INDENT);
				State = 320;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 319; stepStatement();
					}
					}
					State = 322;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << HANDLE_ERROR) | (1L << SCRIPT) | (1L << IDENTIFIER))) != 0) );
				State = 324; Match(DEDENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StepStatementContext : ParserRuleContext {
		public SimpleStepStatementContext simpleStepStatement() {
			return GetRuleContext<SimpleStepStatementContext>(0);
		}
		public CompoundStepStatementContext compoundStepStatement() {
			return GetRuleContext<CompoundStepStatementContext>(0);
		}
		public StepStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stepStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterStepStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitStepStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStepStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StepStatementContext stepStatement() {
		StepStatementContext _localctx = new StepStatementContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_stepStatement);
		try {
			State = 330;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 328; simpleStepStatement();
				}
				break;
			case HANDLE_ERROR:
			case SCRIPT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 329; compoundStepStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleStepStatementContext : ParserRuleContext {
		public PipelineSimpleStepCallContext pipelineSimpleStepCall() {
			return GetRuleContext<PipelineSimpleStepCallContext>(0);
		}
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode SEMICOLON() { return GetToken(BldItParser.SEMICOLON, 0); }
		public SimpleStepStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleStepStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterSimpleStepStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitSimpleStepStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleStepStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleStepStatementContext simpleStepStatement() {
		SimpleStepStatementContext _localctx = new SimpleStepStatementContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_simpleStepStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 332; pipelineSimpleStepCall();
			State = 334;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==SEMICOLON) {
				{
				State = 333; Match(SEMICOLON);
				}
			}

			State = 336; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PipelineSimpleStepCallContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(BldItParser.IDENTIFIER, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(BldItParser.OPEN_PAREN, 0); }
		public ITerminalNode CLOSE_PAREN() { return GetToken(BldItParser.CLOSE_PAREN, 0); }
		public PipelineExpressionContext[] pipelineExpression() {
			return GetRuleContexts<PipelineExpressionContext>();
		}
		public PipelineExpressionContext pipelineExpression(int i) {
			return GetRuleContext<PipelineExpressionContext>(i);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(BldItParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(BldItParser.NEWLINE, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(BldItParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(BldItParser.COMMA, i);
		}
		public PipelineSimpleStepCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pipelineSimpleStepCall; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterPipelineSimpleStepCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitPipelineSimpleStepCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPipelineSimpleStepCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PipelineSimpleStepCallContext pipelineSimpleStepCall() {
		PipelineSimpleStepCallContext _localctx = new PipelineSimpleStepCallContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_pipelineSimpleStepCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 338; Match(IDENTIFIER);
			State = 339; Match(OPEN_PAREN);
			State = 357;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OPEN_PAREN) | (1L << NOT) | (1L << NEWLINE) | (1L << INTEGER) | (1L << FLOAT) | (1L << STRING) | (1L << BOOL) | (1L << NULL) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 341;
				_errHandler.Sync(this);
				_la = _input.La(1);
				if (_la==NEWLINE) {
					{
					State = 340; Match(NEWLINE);
					}
				}

				State = 343; pipelineExpression();
				State = 354;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA || _la==NEWLINE) {
					{
					{
					State = 345;
					_errHandler.Sync(this);
					_la = _input.La(1);
					if (_la==NEWLINE) {
						{
						State = 344; Match(NEWLINE);
						}
					}

					State = 347; Match(COMMA);
					State = 349;
					_errHandler.Sync(this);
					_la = _input.La(1);
					if (_la==NEWLINE) {
						{
						State = 348; Match(NEWLINE);
						}
					}

					State = 351; pipelineExpression();
					}
					}
					State = 356;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 359; Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundStepStatementContext : ParserRuleContext {
		public ScriptStepContext scriptStep() {
			return GetRuleContext<ScriptStepContext>(0);
		}
		public HandleErrorStepContext handleErrorStep() {
			return GetRuleContext<HandleErrorStepContext>(0);
		}
		public CompoundStepStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundStepStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterCompoundStepStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitCompoundStepStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundStepStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompoundStepStatementContext compoundStepStatement() {
		CompoundStepStatementContext _localctx = new CompoundStepStatementContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_compoundStepStatement);
		try {
			State = 363;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case SCRIPT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 361; scriptStep();
				}
				break;
			case HANDLE_ERROR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 362; handleErrorStep();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandleErrorStepContext : ParserRuleContext {
		public ITerminalNode HANDLE_ERROR() { return GetToken(BldItParser.HANDLE_ERROR, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(BldItParser.OPEN_PAREN, 0); }
		public ITerminalNode CLOSE_PAREN() { return GetToken(BldItParser.CLOSE_PAREN, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public HandleErrorBlockContext handleErrorBlock() {
			return GetRuleContext<HandleErrorBlockContext>(0);
		}
		public ITerminalNode[] STRING() { return GetTokens(BldItParser.STRING); }
		public ITerminalNode STRING(int i) {
			return GetToken(BldItParser.STRING, i);
		}
		public ITerminalNode COMMA() { return GetToken(BldItParser.COMMA, 0); }
		public HandleErrorStepContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handleErrorStep; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterHandleErrorStep(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitHandleErrorStep(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandleErrorStep(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandleErrorStepContext handleErrorStep() {
		HandleErrorStepContext _localctx = new HandleErrorStepContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_handleErrorStep);
		try {
			State = 378;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,33,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 365; Match(HANDLE_ERROR);
				State = 366; Match(OPEN_PAREN);
				State = 367; Match(CLOSE_PAREN);
				State = 368; Match(COLON);
				State = 369; handleErrorBlock();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 370; Match(HANDLE_ERROR);
				State = 371; Match(OPEN_PAREN);
				State = 372; Match(STRING);
				State = 373; Match(COMMA);
				State = 374; Match(STRING);
				State = 375; Match(CLOSE_PAREN);
				State = 376; Match(COLON);
				State = 377; handleErrorBlock();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandleErrorBlockContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public StepStatementContext[] stepStatement() {
			return GetRuleContexts<StepStatementContext>();
		}
		public StepStatementContext stepStatement(int i) {
			return GetRuleContext<StepStatementContext>(i);
		}
		public HandleErrorBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handleErrorBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterHandleErrorBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitHandleErrorBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandleErrorBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandleErrorBlockContext handleErrorBlock() {
		HandleErrorBlockContext _localctx = new HandleErrorBlockContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_handleErrorBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 380; Match(NEWLINE);
			State = 381; Match(INDENT);
			State = 383;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 382; stepStatement();
				}
				}
				State = 385;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << HANDLE_ERROR) | (1L << SCRIPT) | (1L << IDENTIFIER))) != 0) );
			State = 387; Match(DEDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScriptStepContext : ParserRuleContext {
		public ITerminalNode SCRIPT() { return GetToken(BldItParser.SCRIPT, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public ScriptBlockContext scriptBlock() {
			return GetRuleContext<ScriptBlockContext>(0);
		}
		public ScriptStepContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scriptStep; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterScriptStep(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitScriptStep(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScriptStep(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptStepContext scriptStep() {
		ScriptStepContext _localctx = new ScriptStepContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_scriptStep);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 389; Match(SCRIPT);
			State = 390; Match(COLON);
			State = 391; scriptBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScriptBlockContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(BldItParser.NEWLINE, 0); }
		public ITerminalNode INDENT() { return GetToken(BldItParser.INDENT, 0); }
		public ScriptStatementsContext scriptStatements() {
			return GetRuleContext<ScriptStatementsContext>(0);
		}
		public ITerminalNode DEDENT() { return GetToken(BldItParser.DEDENT, 0); }
		public ScriptBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scriptBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterScriptBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitScriptBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScriptBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptBlockContext scriptBlock() {
		ScriptBlockContext _localctx = new ScriptBlockContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_scriptBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 393; Match(NEWLINE);
			State = 394; Match(INDENT);
			State = 395; scriptStatements();
			State = 396; Match(DEDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScriptStatementsContext : ParserRuleContext {
		public ScriptStatamentContext[] scriptStatament() {
			return GetRuleContexts<ScriptStatamentContext>();
		}
		public ScriptStatamentContext scriptStatament(int i) {
			return GetRuleContext<ScriptStatamentContext>(i);
		}
		public ScriptStatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scriptStatements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterScriptStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitScriptStatements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScriptStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptStatementsContext scriptStatements() {
		ScriptStatementsContext _localctx = new ScriptStatementsContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_scriptStatements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 399;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 398; scriptStatament();
				}
				}
				State = 401;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << HANDLE_ERROR) | (1L << WHILE) | (1L << FUNCTION) | (1L << RETURN) | (1L << IF) | (1L << SCRIPT) | (1L << IDENTIFIER))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScriptStatamentContext : ParserRuleContext {
		public StepStatementContext stepStatement() {
			return GetRuleContext<StepStatementContext>(0);
		}
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ScriptStatamentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scriptStatament; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterScriptStatament(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitScriptStatament(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScriptStatament(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptStatamentContext scriptStatament() {
		ScriptStatamentContext _localctx = new ScriptStatamentContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_scriptStatament);
		try {
			State = 405;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,36,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 403; stepStatement();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 404; statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnvAssignmentsContext : ParserRuleContext {
		public ITerminalNode[] NEWLINE() { return GetTokens(BldItParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(BldItParser.NEWLINE, i);
		}
		public EnvAssignmentContext[] envAssignment() {
			return GetRuleContexts<EnvAssignmentContext>();
		}
		public EnvAssignmentContext envAssignment(int i) {
			return GetRuleContext<EnvAssignmentContext>(i);
		}
		public ITerminalNode[] SEMICOLON() { return GetTokens(BldItParser.SEMICOLON); }
		public ITerminalNode SEMICOLON(int i) {
			return GetToken(BldItParser.SEMICOLON, i);
		}
		public EnvAssignmentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_envAssignments; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterEnvAssignments(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitEnvAssignments(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnvAssignments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnvAssignmentsContext envAssignments() {
		EnvAssignmentsContext _localctx = new EnvAssignmentsContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_envAssignments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 413;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				{
				State = 407; envAssignment();
				}
				State = 409;
				_errHandler.Sync(this);
				_la = _input.La(1);
				if (_la==SEMICOLON) {
					{
					State = 408; Match(SEMICOLON);
					}
				}

				State = 411; Match(NEWLINE);
				}
				}
				State = 415;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==IDENTIFIER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnvAssignmentContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(BldItParser.IDENTIFIER, 0); }
		public ITerminalNode ASSIGN_OP() { return GetToken(BldItParser.ASSIGN_OP, 0); }
		public PipelineExpressionContext pipelineExpression() {
			return GetRuleContext<PipelineExpressionContext>(0);
		}
		public EnvAssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_envAssignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterEnvAssignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitEnvAssignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnvAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnvAssignmentContext envAssignment() {
		EnvAssignmentContext _localctx = new EnvAssignmentContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_envAssignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 417; Match(IDENTIFIER);
			State = 418; Match(ASSIGN_OP);
			State = 419; pipelineExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamAssignmentsContext : ParserRuleContext {
		public ITerminalNode[] NEWLINE() { return GetTokens(BldItParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(BldItParser.NEWLINE, i);
		}
		public ParamAssignmentContext[] paramAssignment() {
			return GetRuleContexts<ParamAssignmentContext>();
		}
		public ParamAssignmentContext paramAssignment(int i) {
			return GetRuleContext<ParamAssignmentContext>(i);
		}
		public ITerminalNode[] SEMICOLON() { return GetTokens(BldItParser.SEMICOLON); }
		public ITerminalNode SEMICOLON(int i) {
			return GetToken(BldItParser.SEMICOLON, i);
		}
		public ParamAssignmentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paramAssignments; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParamAssignments(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParamAssignments(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParamAssignments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamAssignmentsContext paramAssignments() {
		ParamAssignmentsContext _localctx = new ParamAssignmentsContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_paramAssignments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 427;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				{
				State = 421; paramAssignment();
				}
				State = 423;
				_errHandler.Sync(this);
				_la = _input.La(1);
				if (_la==SEMICOLON) {
					{
					State = 422; Match(SEMICOLON);
					}
				}

				State = 425; Match(NEWLINE);
				}
				}
				State = 429;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==IDENTIFIER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamAssignmentContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(BldItParser.IDENTIFIER, 0); }
		public ITerminalNode COLON() { return GetToken(BldItParser.COLON, 0); }
		public ITerminalNode PARAM_TYPE() { return GetToken(BldItParser.PARAM_TYPE, 0); }
		public ITerminalNode ASSIGN_OP() { return GetToken(BldItParser.ASSIGN_OP, 0); }
		public ParamValueContext paramValue() {
			return GetRuleContext<ParamValueContext>(0);
		}
		public ParamAssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paramAssignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParamAssignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParamAssignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParamAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamAssignmentContext paramAssignment() {
		ParamAssignmentContext _localctx = new ParamAssignmentContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_paramAssignment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 431; Match(IDENTIFIER);
			State = 432; Match(COLON);
			State = 433; Match(PARAM_TYPE);
			State = 436;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==ASSIGN_OP) {
				{
				State = 434; Match(ASSIGN_OP);
				State = 435; paramValue();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamValueContext : ParserRuleContext {
		public ITerminalNode STRING() { return GetToken(BldItParser.STRING, 0); }
		public ITerminalNode BOOL() { return GetToken(BldItParser.BOOL, 0); }
		public ParamValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paramValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterParamValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitParamValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParamValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamValueContext paramValue() {
		ParamValueContext _localctx = new ParamValueContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_paramValue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 438;
			_la = _input.La(1);
			if ( !(_la==STRING || _la==BOOL) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PipelineExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public PipelineExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pipelineExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.EnterPipelineExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IBldItParserListener typedListener = listener as IBldItParserListener;
			if (typedListener != null) typedListener.ExitPipelineExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IBldItParserVisitor<TResult> typedVisitor = visitor as IBldItParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPipelineExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PipelineExpressionContext pipelineExpression() {
		PipelineExpressionContext _localctx = new PipelineExpressionContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_pipelineExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 440; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 17: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 4);

		case 1: return Precpred(_ctx, 3);

		case 2: return Precpred(_ctx, 2);

		case 3: return Precpred(_ctx, 1);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3-\x1BD\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x3\x2\x3\x2\a\x2i\n\x2\f\x2\xE\x2l\v\x2\x3\x2\x3\x2"+
		"\x3\x2\x3\x3\x6\x3r\n\x3\r\x3\xE\x3s\x3\x4\x3\x4\x5\x4x\n\x4\x3\x5\x3"+
		"\x5\x3\x5\x5\x5}\n\x5\x3\x5\x5\x5\x80\n\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3"+
		"\x6\x5\x6\x87\n\x6\x3\a\x3\a\a\a\x8B\n\a\f\a\xE\a\x8E\v\a\x3\a\x5\a\x91"+
		"\n\a\x3\b\x3\b\x3\b\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\n\x3\n"+
		"\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\f\x3\f\x3\f\x3\f\x5\f\xAB\n\f\x3"+
		"\f\x3\f\x3\f\x3\f\x3\r\x3\r\x3\r\a\r\xB4\n\r\f\r\xE\r\xB7\v\r\x3\xE\x3"+
		"\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xBF\n\xE\x3\xF\x3\xF\x3\xF\x3\xF\x5"+
		"\xF\xC5\n\xF\x3\xF\x5\xF\xC8\n\xF\x3\x10\x3\x10\x5\x10\xCC\n\x10\x3\x11"+
		"\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\a\x12\xD7\n\x12"+
		"\f\x12\xE\x12\xDA\v\x12\x5\x12\xDC\n\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3"+
		"\x13\x3\x13\x3\x13\x3\x13\x5\x13\xE6\n\x13\x3\x13\x3\x13\x3\x13\x3\x13"+
		"\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13"+
		"\x3\x13\x3\x13\a\x13\xF8\n\x13\f\x13\xE\x13\xFB\v\x13\x3\x14\x3\x14\x3"+
		"\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x17\x3\x17\x3\x18\x3"+
		"\x18\x3\x19\x3\x19\x3\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5"+
		"\x1B\x113\n\x1B\x3\x1B\x5\x1B\x116\n\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1C\x3"+
		"\x1C\x3\x1C\x3\x1C\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1E\x3\x1E\x3\x1E\x3"+
		"\x1E\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3 \x3 \x3 \x3 \x3 \x3!\x3!\x3"+
		"!\x6!\x134\n!\r!\xE!\x135\x3!\x3!\x3\"\x3\"\x3\"\x3\"\x3\"\x3#\x3#\x3"+
		"#\x3#\x6#\x143\n#\r#\xE#\x144\x3#\x3#\x5#\x149\n#\x3$\x3$\x5$\x14D\n$"+
		"\x3%\x3%\x5%\x151\n%\x3%\x3%\x3&\x3&\x3&\x5&\x158\n&\x3&\x3&\x5&\x15C"+
		"\n&\x3&\x3&\x5&\x160\n&\x3&\a&\x163\n&\f&\xE&\x166\v&\x5&\x168\n&\x3&"+
		"\x3&\x3\'\x3\'\x5\'\x16E\n\'\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3"+
		"(\x3(\x3(\x5(\x17D\n(\x3)\x3)\x3)\x6)\x182\n)\r)\xE)\x183\x3)\x3)\x3*"+
		"\x3*\x3*\x3*\x3+\x3+\x3+\x3+\x3+\x3,\x6,\x192\n,\r,\xE,\x193\x3-\x3-\x5"+
		"-\x198\n-\x3.\x3.\x5.\x19C\n.\x3.\x3.\x6.\x1A0\n.\r.\xE.\x1A1\x3/\x3/"+
		"\x3/\x3/\x3\x30\x3\x30\x5\x30\x1AA\n\x30\x3\x30\x3\x30\x6\x30\x1AE\n\x30"+
		"\r\x30\xE\x30\x1AF\x3\x31\x3\x31\x3\x31\x3\x31\x3\x31\x5\x31\x1B7\n\x31"+
		"\x3\x32\x3\x32\x3\x33\x3\x33\x3\x33\x2\x2\x3$\x34\x2\x2\x4\x2\x6\x2\b"+
		"\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E"+
		"\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2"+
		":\x2<\x2>\x2@\x2\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2"+
		"X\x2Z\x2\\\x2^\x2`\x2\x62\x2\x64\x2\x2\a\x3\x2\x10\x12\x3\x2\xE\xF\x4"+
		"\x2\x14\x17!!\x3\x2\'+\x3\x2)*\x1BB\x2j\x3\x2\x2\x2\x4q\x3\x2\x2\x2\x6"+
		"w\x3\x2\x2\x2\b|\x3\x2\x2\x2\n\x86\x3\x2\x2\x2\f\x88\x3\x2\x2\x2\xE\x92"+
		"\x3\x2\x2\x2\x10\x97\x3\x2\x2\x2\x12\x9D\x3\x2\x2\x2\x14\xA1\x3\x2\x2"+
		"\x2\x16\xA6\x3\x2\x2\x2\x18\xB0\x3\x2\x2\x2\x1A\xBE\x3\x2\x2\x2\x1C\xC7"+
		"\x3\x2\x2\x2\x1E\xC9\x3\x2\x2\x2 \xCD\x3\x2\x2\x2\"\xD1\x3\x2\x2\x2$\xE5"+
		"\x3\x2\x2\x2&\xFC\x3\x2\x2\x2(\x100\x3\x2\x2\x2*\x103\x3\x2\x2\x2,\x105"+
		"\x3\x2\x2\x2.\x107\x3\x2\x2\x2\x30\x109\x3\x2\x2\x2\x32\x10B\x3\x2\x2"+
		"\x2\x34\x10D\x3\x2\x2\x2\x36\x11A\x3\x2\x2\x2\x38\x11E\x3\x2\x2\x2:\x122"+
		"\x3\x2\x2\x2<\x126\x3\x2\x2\x2>\x12B\x3\x2\x2\x2@\x130\x3\x2\x2\x2\x42"+
		"\x139\x3\x2\x2\x2\x44\x148\x3\x2\x2\x2\x46\x14C\x3\x2\x2\x2H\x14E\x3\x2"+
		"\x2\x2J\x154\x3\x2\x2\x2L\x16D\x3\x2\x2\x2N\x17C\x3\x2\x2\x2P\x17E\x3"+
		"\x2\x2\x2R\x187\x3\x2\x2\x2T\x18B\x3\x2\x2\x2V\x191\x3\x2\x2\x2X\x197"+
		"\x3\x2\x2\x2Z\x19F\x3\x2\x2\x2\\\x1A3\x3\x2\x2\x2^\x1AD\x3\x2\x2\x2`\x1B1"+
		"\x3\x2\x2\x2\x62\x1B8\x3\x2\x2\x2\x64\x1BA\x3\x2\x2\x2\x66i\a%\x2\x2g"+
		"i\x5\x6\x4\x2h\x66\x3\x2\x2\x2hg\x3\x2\x2\x2il\x3\x2\x2\x2jh\x3\x2\x2"+
		"\x2jk\x3\x2\x2\x2km\x3\x2\x2\x2lj\x3\x2\x2\x2mn\x5\x34\x1B\x2no\a\x2\x2"+
		"\x3o\x3\x3\x2\x2\x2pr\x5\x6\x4\x2qp\x3\x2\x2\x2rs\x3\x2\x2\x2sq\x3\x2"+
		"\x2\x2st\x3\x2\x2\x2t\x5\x3\x2\x2\x2ux\x5\b\x5\x2vx\x5\n\x6\x2wu\x3\x2"+
		"\x2\x2wv\x3\x2\x2\x2x\a\x3\x2\x2\x2y}\x5 \x11\x2z}\x5\"\x12\x2{}\x5\x1E"+
		"\x10\x2|y\x3\x2\x2\x2|z\x3\x2\x2\x2|{\x3\x2\x2\x2}\x7F\x3\x2\x2\x2~\x80"+
		"\a\x1B\x2\x2\x7F~\x3\x2\x2\x2\x7F\x80\x3\x2\x2\x2\x80\x81\x3\x2\x2\x2"+
		"\x81\x82\a%\x2\x2\x82\t\x3\x2\x2\x2\x83\x87\x5\f\a\x2\x84\x87\x5\x14\v"+
		"\x2\x85\x87\x5\x16\f\x2\x86\x83\x3\x2\x2\x2\x86\x84\x3\x2\x2\x2\x86\x85"+
		"\x3\x2\x2\x2\x87\v\x3\x2\x2\x2\x88\x8C\x5\xE\b\x2\x89\x8B\x5\x10\t\x2"+
		"\x8A\x89\x3\x2\x2\x2\x8B\x8E\x3\x2\x2\x2\x8C\x8A\x3\x2\x2\x2\x8C\x8D\x3"+
		"\x2\x2\x2\x8D\x90\x3\x2\x2\x2\x8E\x8C\x3\x2\x2\x2\x8F\x91\x5\x12\n\x2"+
		"\x90\x8F\x3\x2\x2\x2\x90\x91\x3\x2\x2\x2\x91\r\x3\x2\x2\x2\x92\x93\a\x1F"+
		"\x2\x2\x93\x94\x5$\x13\x2\x94\x95\a\x1C\x2\x2\x95\x96\x5\x1A\xE\x2\x96"+
		"\xF\x3\x2\x2\x2\x97\x98\a \x2\x2\x98\x99\a\x1F\x2\x2\x99\x9A\x5$\x13\x2"+
		"\x9A\x9B\a\x1C\x2\x2\x9B\x9C\x5\x1A\xE\x2\x9C\x11\x3\x2\x2\x2\x9D\x9E"+
		"\a \x2\x2\x9E\x9F\a\x1C\x2\x2\x9F\xA0\x5\x1A\xE\x2\xA0\x13\x3\x2\x2\x2"+
		"\xA1\xA2\a\v\x2\x2\xA2\xA3\x5$\x13\x2\xA3\xA4\a\x1C\x2\x2\xA4\xA5\x5\x1A"+
		"\xE\x2\xA5\x15\x3\x2\x2\x2\xA6\xA7\a\f\x2\x2\xA7\xA8\a-\x2\x2\xA8\xAA"+
		"\a\x18\x2\x2\xA9\xAB\x5\x18\r\x2\xAA\xA9\x3\x2\x2\x2\xAA\xAB\x3\x2\x2"+
		"\x2\xAB\xAC\x3\x2\x2\x2\xAC\xAD\a\x19\x2\x2\xAD\xAE\a\x1C\x2\x2\xAE\xAF"+
		"\x5\x1C\xF\x2\xAF\x17\x3\x2\x2\x2\xB0\xB5\a-\x2\x2\xB1\xB2\a\x1A\x2\x2"+
		"\xB2\xB4\a-\x2\x2\xB3\xB1\x3\x2\x2\x2\xB4\xB7\x3\x2\x2\x2\xB5\xB3\x3\x2"+
		"\x2\x2\xB5\xB6\x3\x2\x2\x2\xB6\x19\x3\x2\x2\x2\xB7\xB5\x3\x2\x2\x2\xB8"+
		"\xBF\x5\b\x5\x2\xB9\xBA\a%\x2\x2\xBA\xBB\a\x3\x2\x2\xBB\xBC\x5\x4\x3\x2"+
		"\xBC\xBD\a\x4\x2\x2\xBD\xBF\x3\x2\x2\x2\xBE\xB8\x3\x2\x2\x2\xBE\xB9\x3"+
		"\x2\x2\x2\xBF\x1B\x3\x2\x2\x2\xC0\xC8\x5\b\x5\x2\xC1\xC2\a%\x2\x2\xC2"+
		"\xC4\a\x3\x2\x2\xC3\xC5\x5\x4\x3\x2\xC4\xC3\x3\x2\x2\x2\xC4\xC5\x3\x2"+
		"\x2\x2\xC5\xC6\x3\x2\x2\x2\xC6\xC8\a\x4\x2\x2\xC7\xC0\x3\x2\x2\x2\xC7"+
		"\xC1\x3\x2\x2\x2\xC8\x1D\x3\x2\x2\x2\xC9\xCB\a\r\x2\x2\xCA\xCC\x5$\x13"+
		"\x2\xCB\xCA\x3\x2\x2\x2\xCB\xCC\x3\x2\x2\x2\xCC\x1F\x3\x2\x2\x2\xCD\xCE"+
		"\a-\x2\x2\xCE\xCF\a\x1E\x2\x2\xCF\xD0\x5$\x13\x2\xD0!\x3\x2\x2\x2\xD1"+
		"\xD2\a-\x2\x2\xD2\xDB\a\x18\x2\x2\xD3\xD8\x5$\x13\x2\xD4\xD5\a\x1A\x2"+
		"\x2\xD5\xD7\x5$\x13\x2\xD6\xD4\x3\x2\x2\x2\xD7\xDA\x3\x2\x2\x2\xD8\xD6"+
		"\x3\x2\x2\x2\xD8\xD9\x3\x2\x2\x2\xD9\xDC\x3\x2\x2\x2\xDA\xD8\x3\x2\x2"+
		"\x2\xDB\xD3\x3\x2\x2\x2\xDB\xDC\x3\x2\x2\x2\xDC\xDD\x3\x2\x2\x2\xDD\xDE"+
		"\a\x19\x2\x2\xDE#\x3\x2\x2\x2\xDF\xE0\b\x13\x1\x2\xE0\xE6\x5\x32\x1A\x2"+
		"\xE1\xE6\a-\x2\x2\xE2\xE6\x5\"\x12\x2\xE3\xE6\x5&\x14\x2\xE4\xE6\x5(\x15"+
		"\x2\xE5\xDF\x3\x2\x2\x2\xE5\xE1\x3\x2\x2\x2\xE5\xE2\x3\x2\x2\x2\xE5\xE3"+
		"\x3\x2\x2\x2\xE5\xE4\x3\x2\x2\x2\xE6\xF9\x3\x2\x2\x2\xE7\xE8\f\x6\x2\x2"+
		"\xE8\xE9\x5*\x16\x2\xE9\xEA\x5$\x13\a\xEA\xF8\x3\x2\x2\x2\xEB\xEC\f\x5"+
		"\x2\x2\xEC\xED\x5,\x17\x2\xED\xEE\x5$\x13\x6\xEE\xF8\x3\x2\x2\x2\xEF\xF0"+
		"\f\x4\x2\x2\xF0\xF1\x5.\x18\x2\xF1\xF2\x5$\x13\x5\xF2\xF8\x3\x2\x2\x2"+
		"\xF3\xF4\f\x3\x2\x2\xF4\xF5\x5\x30\x19\x2\xF5\xF6\x5$\x13\x4\xF6\xF8\x3"+
		"\x2\x2\x2\xF7\xE7\x3\x2\x2\x2\xF7\xEB\x3\x2\x2\x2\xF7\xEF\x3\x2\x2\x2"+
		"\xF7\xF3\x3\x2\x2\x2\xF8\xFB\x3\x2\x2\x2\xF9\xF7\x3\x2\x2\x2\xF9\xFA\x3"+
		"\x2\x2\x2\xFA%\x3\x2\x2\x2\xFB\xF9\x3\x2\x2\x2\xFC\xFD\a\x18\x2\x2\xFD"+
		"\xFE\x5$\x13\x2\xFE\xFF\a\x19\x2\x2\xFF\'\x3\x2\x2\x2\x100\x101\a\"\x2"+
		"\x2\x101\x102\x5$\x13\x2\x102)\x3\x2\x2\x2\x103\x104\t\x2\x2\x2\x104+"+
		"\x3\x2\x2\x2\x105\x106\t\x3\x2\x2\x106-\x3\x2\x2\x2\x107\x108\t\x4\x2"+
		"\x2\x108/\x3\x2\x2\x2\x109\x10A\a\x13\x2\x2\x10A\x31\x3\x2\x2\x2\x10B"+
		"\x10C\t\x5\x2\x2\x10C\x33\x3\x2\x2\x2\x10D\x10E\a\x5\x2\x2\x10E\x10F\a"+
		"\x1C\x2\x2\x10F\x110\a%\x2\x2\x110\x112\a\x3\x2\x2\x111\x113\x5\x36\x1C"+
		"\x2\x112\x111\x3\x2\x2\x2\x112\x113\x3\x2\x2\x2\x113\x115\x3\x2\x2\x2"+
		"\x114\x116\x5\x38\x1D\x2\x115\x114\x3\x2\x2\x2\x115\x116\x3\x2\x2\x2\x116"+
		"\x117\x3\x2\x2\x2\x117\x118\x5:\x1E\x2\x118\x119\a\x4\x2\x2\x119\x35\x3"+
		"\x2\x2\x2\x11A\x11B\a\x6\x2\x2\x11B\x11C\a\x1C\x2\x2\x11C\x11D\x5<\x1F"+
		"\x2\x11D\x37\x3\x2\x2\x2\x11E\x11F\a\a\x2\x2\x11F\x120\a\x1C\x2\x2\x120"+
		"\x121\x5> \x2\x121\x39\x3\x2\x2\x2\x122\x123\a\b\x2\x2\x123\x124\a\x1C"+
		"\x2\x2\x124\x125\x5@!\x2\x125;\x3\x2\x2\x2\x126\x127\a%\x2\x2\x127\x128"+
		"\a\x3\x2\x2\x128\x129\x5Z.\x2\x129\x12A\a\x4\x2\x2\x12A=\x3\x2\x2\x2\x12B"+
		"\x12C\a%\x2\x2\x12C\x12D\a\x3\x2\x2\x12D\x12E\x5^\x30\x2\x12E\x12F\a\x4"+
		"\x2\x2\x12F?\x3\x2\x2\x2\x130\x131\a%\x2\x2\x131\x133\a\x3\x2\x2\x132"+
		"\x134\x5\x42\"\x2\x133\x132\x3\x2\x2\x2\x134\x135\x3\x2\x2\x2\x135\x133"+
		"\x3\x2\x2\x2\x135\x136\x3\x2\x2\x2\x136\x137\x3\x2\x2\x2\x137\x138\a\x4"+
		"\x2\x2\x138\x41\x3\x2\x2\x2\x139\x13A\a\t\x2\x2\x13A\x13B\a)\x2\x2\x13B"+
		"\x13C\a\x1C\x2\x2\x13C\x13D\x5\x44#\x2\x13D\x43\x3\x2\x2\x2\x13E\x149"+
		"\x5H%\x2\x13F\x140\a%\x2\x2\x140\x142\a\x3\x2\x2\x141\x143\x5\x46$\x2"+
		"\x142\x141\x3\x2\x2\x2\x143\x144\x3\x2\x2\x2\x144\x142\x3\x2\x2\x2\x144"+
		"\x145\x3\x2\x2\x2\x145\x146\x3\x2\x2\x2\x146\x147\a\x4\x2\x2\x147\x149"+
		"\x3\x2\x2\x2\x148\x13E\x3\x2\x2\x2\x148\x13F\x3\x2\x2\x2\x149\x45\x3\x2"+
		"\x2\x2\x14A\x14D\x5H%\x2\x14B\x14D\x5L\'\x2\x14C\x14A\x3\x2\x2\x2\x14C"+
		"\x14B\x3\x2\x2\x2\x14DG\x3\x2\x2\x2\x14E\x150\x5J&\x2\x14F\x151\a\x1B"+
		"\x2\x2\x150\x14F\x3\x2\x2\x2\x150\x151\x3\x2\x2\x2\x151\x152\x3\x2\x2"+
		"\x2\x152\x153\a%\x2\x2\x153I\x3\x2\x2\x2\x154\x155\a-\x2\x2\x155\x167"+
		"\a\x18\x2\x2\x156\x158\a%\x2\x2\x157\x156\x3\x2\x2\x2\x157\x158\x3\x2"+
		"\x2\x2\x158\x159\x3\x2\x2\x2\x159\x164\x5\x64\x33\x2\x15A\x15C\a%\x2\x2"+
		"\x15B\x15A\x3\x2\x2\x2\x15B\x15C\x3\x2\x2\x2\x15C\x15D\x3\x2\x2\x2\x15D"+
		"\x15F\a\x1A\x2\x2\x15E\x160\a%\x2\x2\x15F\x15E\x3\x2\x2\x2\x15F\x160\x3"+
		"\x2\x2\x2\x160\x161\x3\x2\x2\x2\x161\x163\x5\x64\x33\x2\x162\x15B\x3\x2"+
		"\x2\x2\x163\x166\x3\x2\x2\x2\x164\x162\x3\x2\x2\x2\x164\x165\x3\x2\x2"+
		"\x2\x165\x168\x3\x2\x2\x2\x166\x164\x3\x2\x2\x2\x167\x157\x3\x2\x2\x2"+
		"\x167\x168\x3\x2\x2\x2\x168\x169\x3\x2\x2\x2\x169\x16A\a\x19\x2\x2\x16A"+
		"K\x3\x2\x2\x2\x16B\x16E\x5R*\x2\x16C\x16E\x5N(\x2\x16D\x16B\x3\x2\x2\x2"+
		"\x16D\x16C\x3\x2\x2\x2\x16EM\x3\x2\x2\x2\x16F\x170\a\n\x2\x2\x170\x171"+
		"\a\x18\x2\x2\x171\x172\a\x19\x2\x2\x172\x173\a\x1C\x2\x2\x173\x17D\x5"+
		"P)\x2\x174\x175\a\n\x2\x2\x175\x176\a\x18\x2\x2\x176\x177\a)\x2\x2\x177"+
		"\x178\a\x1A\x2\x2\x178\x179\a)\x2\x2\x179\x17A\a\x19\x2\x2\x17A\x17B\a"+
		"\x1C\x2\x2\x17B\x17D\x5P)\x2\x17C\x16F\x3\x2\x2\x2\x17C\x174\x3\x2\x2"+
		"\x2\x17DO\x3\x2\x2\x2\x17E\x17F\a%\x2\x2\x17F\x181\a\x3\x2\x2\x180\x182"+
		"\x5\x46$\x2\x181\x180\x3\x2\x2\x2\x182\x183\x3\x2\x2\x2\x183\x181\x3\x2"+
		"\x2\x2\x183\x184\x3\x2\x2\x2\x184\x185\x3\x2\x2\x2\x185\x186\a\x4\x2\x2"+
		"\x186Q\x3\x2\x2\x2\x187\x188\a$\x2\x2\x188\x189\a\x1C\x2\x2\x189\x18A"+
		"\x5T+\x2\x18AS\x3\x2\x2\x2\x18B\x18C\a%\x2\x2\x18C\x18D\a\x3\x2\x2\x18D"+
		"\x18E\x5V,\x2\x18E\x18F\a\x4\x2\x2\x18FU\x3\x2\x2\x2\x190\x192\x5X-\x2"+
		"\x191\x190\x3\x2\x2\x2\x192\x193\x3\x2\x2\x2\x193\x191\x3\x2\x2\x2\x193"+
		"\x194\x3\x2\x2\x2\x194W\x3\x2\x2\x2\x195\x198\x5\x46$\x2\x196\x198\x5"+
		"\x6\x4\x2\x197\x195\x3\x2\x2\x2\x197\x196\x3\x2\x2\x2\x198Y\x3\x2\x2\x2"+
		"\x199\x19B\x5\\/\x2\x19A\x19C\a\x1B\x2\x2\x19B\x19A\x3\x2\x2\x2\x19B\x19C"+
		"\x3\x2\x2\x2\x19C\x19D\x3\x2\x2\x2\x19D\x19E\a%\x2\x2\x19E\x1A0\x3\x2"+
		"\x2\x2\x19F\x199\x3\x2\x2\x2\x1A0\x1A1\x3\x2\x2\x2\x1A1\x19F\x3\x2\x2"+
		"\x2\x1A1\x1A2\x3\x2\x2\x2\x1A2[\x3\x2\x2\x2\x1A3\x1A4\a-\x2\x2\x1A4\x1A5"+
		"\a\x1E\x2\x2\x1A5\x1A6\x5\x64\x33\x2\x1A6]\x3\x2\x2\x2\x1A7\x1A9\x5`\x31"+
		"\x2\x1A8\x1AA\a\x1B\x2\x2\x1A9\x1A8\x3\x2\x2\x2\x1A9\x1AA\x3\x2\x2\x2"+
		"\x1AA\x1AB\x3\x2\x2\x2\x1AB\x1AC\a%\x2\x2\x1AC\x1AE\x3\x2\x2\x2\x1AD\x1A7"+
		"\x3\x2\x2\x2\x1AE\x1AF\x3\x2\x2\x2\x1AF\x1AD\x3\x2\x2\x2\x1AF\x1B0\x3"+
		"\x2\x2\x2\x1B0_\x3\x2\x2\x2\x1B1\x1B2\a-\x2\x2\x1B2\x1B3\a\x1C\x2\x2\x1B3"+
		"\x1B6\a#\x2\x2\x1B4\x1B5\a\x1E\x2\x2\x1B5\x1B7\x5\x62\x32\x2\x1B6\x1B4"+
		"\x3\x2\x2\x2\x1B6\x1B7\x3\x2\x2\x2\x1B7\x61\x3\x2\x2\x2\x1B8\x1B9\t\x6"+
		"\x2\x2\x1B9\x63\x3\x2\x2\x2\x1BA\x1BB\x5$\x13\x2\x1BB\x65\x3\x2\x2\x2"+
		",hjsw|\x7F\x86\x8C\x90\xAA\xB5\xBE\xC4\xC7\xCB\xD8\xDB\xE5\xF7\xF9\x112"+
		"\x115\x135\x144\x148\x14C\x150\x157\x15B\x15F\x164\x167\x16D\x17C\x183"+
		"\x193\x197\x19B\x1A1\x1A9\x1AF\x1B6";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace BldIt.Lang.Grammar
